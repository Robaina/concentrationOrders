function out = MATLAB_parallel(GEM, dx_eps, v_eps, v_lb, v_ub,ncores)

%This function evaluates whether there exists reaction pairs i,j whose flux
%value at steady-state (i.e., when Sv = 0) satisfy v_i > v_j for all
%possible flux distributions. Result: 1 means v_i > v_j, 2 means v_i < v_j.
%It only searches for flux distributions inside the flux cone, hence lower
%bounds are set to veps to guarantee that none is zero.
%
% Output:
% out.Adj_ge: a matrix with entries, 
%    0 if no order relation between v_i, v_j
%    1 if v_i >= v_j
%
%   Semidan Robaina Estevez (robaina@mpimp-golm.mpg.de)
%**************************************************************************

% Remove blocked reactions and split reversible reactions
if ~isfield(GEM,'reduced')
   [GEM,out.Unblocked] = myreduceModel(GEM);
end
if sum(GEM.rev > 0)
   GEM = splitGEM(GEM);
end

out.GEMr = GEM;
S = GEM.S;
nrxns = size(S,2);
nmets = size(S,1);

% Evaluate argument
if nargin < 2 || isempty(dx_eps)
  dx_eps = 0;
end

if nargin < 3 || isempty(v_eps)
  v_eps = 1e-9;
end

if nargin < 4 || isempty(v_lb)
  v_lb = zeros(nrxns,1);
end

if nargin < 5 || isempty(v_ub)
  v_ub = 1e3*ones(nrxns,1);
end

if nargin < 6 || isempty(ncores)
  ncores = [];
end

% Initialize LP problem
if dx_eps == 0
   sense = [repmat('=',nmets,1);repmat('<',nrxns,1);repmat('>',nrxns,1);'='];
   rhs = [zeros(nmets + 2*nrxns,1);1];
   A11 = [S,zeros(nmets,1)];
   A12 = [[eye(nrxns),-v_ub];[eye(nrxns),-v_lb]];
   A1 = [A11;A12];
   elseif dx_eps > 0
   sense = [repmat('<',nmets,1);repmat('>',nmets,1);repmat('<',nrxns,1);repmat('>',nrxns,1);'='];
   rhs = [dx_eps*ones(nmets,1);-dx_eps*ones(nmets,1);zeros(2*nrxns,1);1];
   A11 = [[S,zeros(nmets,1)];[S,zeros(nmets,1)]];
   A12 = [[eye(nrxns),-v_ub];[eye(nrxns),-v_lb]];
   A1 = [A11;A12];
end

lb = zeros(nrxns + 1,1);
ub = 1e9*ones(nrxns + 1,1);

%Compute all pairs
rxn_pairs = combnk(1:nrxns,2);
npairs = 0.5*nrxns*(nrxns - 1);
A_id = zeros(npairs,1);
pairsIdx = zeros(npairs,1);
pairsIdx_rev = pairsIdx;

for idx = 1:npairs
    pairsIdx(idx) = sub2ind([nrxns,nrxns],rxn_pairs(idx,1),rxn_pairs(idx,2));
    pairsIdx_rev(idx) = sub2ind([nrxns,nrxns],rxn_pairs(idx,2),rxn_pairs(idx,1));
end
   
%Create parallel pool and set progress bar
parpool(ncores)
ppm = ParforProgMon('Finding reaction orders...', npairs);

tic
%Main loop: Prepare adjacency matrix of the Hasse diagram
parfor n = 1:npairs
    
	[idx,jdx] = ind2sub([nrxns,nrxns],pairsIdx(n))
    
    ppm.increment();
	
	c = zeros(1,nrxns + 1);
	c(idx) = 1;
	A2 = zeros(1,nrxns + 1);
	A2(jdx) = 1;
	model = struct();
    model.obj = c;
	model.rhs = rhs;
	model.lb = lb;
	model.ub = ub;
	model.sense = sense;
	model.A = sparse([A1;A2]);
	params = struct('OutputFlag',0);
	model.modelsense = 'min';
	gurmin = gurobi(model,params); 
	model.modelsense = 'max';
	gurmax = gurobi(model,params); 

	try
		if gurmin.objval >= 1 && gurmax.objval > 1
			A_id(n) = 1;
		end
		if gurmin.objval < 1 && gurmax.objval <= 1
			A_id(n) = -1;
        end 
        
    catch
        
    end
end

%Reconstruct adjacency matrix
Adj_ge = zeros(nrxns);
for idx = 1:npairs
    if A_id(idx) == 1
        Adj_ge(rxn_pairs(idx,1),rxn_pairs(idx,2)) = 1;
    elseif A_id(idx) == -1
        Adj_ge(rxn_pairs(idx,2),rxn_pairs(idx,1)) = 1;
    end
end

%Prepare output
out.Time = toc;
out.Adj_ge = Adj_ge;
csvwrite('Adj_ge.csv',Adj_ge)

%Shut down coworkers
delete(gcp('nocreate'))
end


